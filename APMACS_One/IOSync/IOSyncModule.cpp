///////////////////////////////////////////////////////////////////////////////
// IOSyncModule.cpp
#include "TcPch.h"
#pragma hdrstop

#include "IOSyncModule.h"
#include "IOSyncModuleAds.h"
#include "IOSyncVersion.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CIOSyncModule
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CIOSyncModule
BEGIN_INTERFACE_MAP(CIOSyncModule)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
	INTERFACE_ENTRY(IID_ITcPostCyclic, ITcPostCyclic)
	INTERFACE_ENTRY(IID_IIOSyncInterface, IIOSyncInterface)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_IPERSIST_LIB(CIOSyncModule, VID_IOSync, CID_IOSyncCIOSyncModule)
IMPLEMENT_ITCOMOBJECT(CIOSyncModule)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CIOSyncModule)
IMPLEMENT_ITCADI(CIOSyncModule)
IMPLEMENT_ITCWATCHSOURCE(CIOSyncModule)

///////////////////////////////////////////////////////////////////////////////
// Set parameters of CIOSyncModule 
BEGIN_SETOBJPARA_MAP(CIOSyncModule)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_IOSyncModuleDefaultAdsPort, m_DefaultAdsPort)
	SETOBJPARA_VALUE(PID_Ctx_AdsPort, m_ContextAdsPort)
	SETOBJPARA_VALUE(PID_IOSyncModuleCounter, m_Counter)
	SETOBJPARA_VALUE(PID_IOSyncModuleMyContextId, m_MyContextId)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	SETOBJPARA_ITFPTR(PID_IOSyncModuleRTime, m_spRTime)
	SETOBJPARA_ITFPTR(PID_IOSyncModulePostCyclicCaller, m_spPostCyclicCaller)
	SETOBJPARA_DATAPTR(PID_IOSyncModuleCurPentTimePtr, m_spCurPentTimePtr)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CIOSyncModule 
BEGIN_GETOBJPARA_MAP(CIOSyncModule)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_IOSyncModuleDefaultAdsPort, m_DefaultAdsPort)
	GETOBJPARA_VALUE(PID_Ctx_AdsPort, m_ContextAdsPort)
	GETOBJPARA_VALUE(PID_IOSyncModuleCounter, m_Counter)
	GETOBJPARA_VALUE(PID_IOSyncModuleMyContextId, m_MyContextId)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	GETOBJPARA_ITFPTR(PID_IOSyncModuleRTime, m_spRTime)
	GETOBJPARA_ITFPTR(PID_IOSyncModulePostCyclicCaller, m_spPostCyclicCaller)
///</AutoGeneratedContent>
	GETOBJPARA_TYPE_CODE(PID_IOSyncModuleAdsPort, WORD, *p = AmsGetPort())
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CIOSyncModule
BEGIN_OBJPARAWATCH_MAP(CIOSyncModule)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
	OBJPARAWATCH_VALUE(PID_IOSyncModuleCounter, m_Counter)
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CIOSyncModule
BEGIN_OBJDATAAREA_MAP(CIOSyncModule)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_IOSyncModuleInputs, m_Inputs)
	OBJDATAAREA_VALUE(ADI_IOSyncModuleOutputs, m_Outputs)
	OBJDATAAREA_VALUE(ADI_IOSyncModuleDebug, m_Debug)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CIOSyncModule::CIOSyncModule()
	: m_Trace(m_TraceLevelMax, m_spSrv)
	, m_log(0x12C)						// #@@# LTW
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	m_DefaultAdsPort = 0;
	m_ContextAdsPort = 0;
	m_Counter = 0;
	m_MyContextId = 0;
	memset(&m_Inputs, 0, sizeof(m_Inputs));
	memset(&m_Outputs, 0, sizeof(m_Outputs));
	memset(&m_Debug, 0, sizeof(m_Debug));
///</AutoGeneratedContent>

	WaitTillOutputReadyOpt = false; 

	m_Debug.DelayUsec = 50;
	m_Debug.MaxWaitUsec = 100;
	m_Debug.NumSyncModule = 0;

	m_Debug.TimeDiffLimit = 60;	//-- 60 units of 100nsec or 6 usec
 	m_Debug.GoodCount = 0;
	m_Debug.BadCount = 0;


	//-- data structure must be initialized on power up. I found that sync flag can be non-zero on power up.
	for (short i = 0; i < NUM_IO_SYNC; i++)
	{
		IOSyncList[i].syncFlag = false;
		IOSyncList[i].inputReadyFlag = false;
		IOSyncList[i].outputReadyFlag = false;
		IOSyncList[i].inputReadyTimeout = 0;
		IOSyncList[i].outputReadyTimeout = 0;
	}
}

///////////////////////////////////////////////////////////////////////////////
CIOSyncModule::~CIOSyncModule() 
{
}

///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CIOSyncModule)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CIOSyncModule::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	hr = SUCCEEDED(hr) ? InitAmsPort(m_spSrv, m_DefaultAdsPort) : hr;

	// #@@# LTW Initialize log mark
	m_log.SetContextId(m_MyContextId);// (1);	//-- NOTE: 0.1.0.1 each instance specifies contextId for RealTimeMonitor software.
	hr = m_log.InitLogMark(m_spSrv);

	// cleanup on failure
	if (FAILED(hr))
	{
		ShutdownAmsPort();
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CIOSyncModule::SetObjStateSO()
{
	//m_Trace.Log(tlVerbose, FENTERA);
	m_Trace.Log(tlInfo, FENTERA);
	HRESULT hr = S_OK;

	// TODO: Add any additional initialization
	//#@@# LTW get reference to TC-RTime-Instance
	m_spRTime.SetOID(OID_TCRTIME_CTRL);														//-- set object ID
	hr = FAILED(hr) ? hr : m_spSrv->TcQuerySmartObjectInterface(m_spRTime);					//-- initialize pointer
	hr = FAILED(hr) ? hr : AddModuleToPostCyclicCaller();

	// Initialize data pointer
	hr = FAILED(hr) ? hr : InitDataPointer();


	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before this method has been left.
	//hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		//RemoveModuleFromCaller(); 

		// #@@# LTW
		m_spRTime = NULL;
		RemoveModuleFromPosyCyclicCaller();
		
		DeinitDataPointer();
	}
	m_Trace.Log(tlInfo, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CIOSyncModule::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	//RemoveModuleFromCaller(); 
	
	//#@@# LTW
	m_spRTime = NULL;
	RemoveModuleFromPosyCyclicCaller();
	
	DeinitDataPointer();

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CIOSyncModule::SetObjStateSP()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	ShutdownAmsPort();

	//#@@# LTW De-initialize log mark 
	m_log.ReleaseLogMark();

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT CIOSyncModule::InitDataPointer()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if(m_spCurPentTimePtr.HasOID())	hr = FAILED(hr) ? hr : m_spCurPentTimePtr.Init(m_spSrv);	//-- If data pointer is not mapped for object instance, do not initialize pointer. otherwise, TC triggers invalid object paramters when transitioning to OP state

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CIOSyncModule::DeinitDataPointer()
{
	m_Trace.Log(tlVerbose, FENTERA);

	m_spCurPentTimePtr = NULL;

	m_Trace.Log(tlVerbose, FLEAVEA);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CIOSyncModule::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if (m_spCyclicCaller.HasOID())
	{
		if (SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)))
		{
			if (FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))))
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID;
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CIOSyncModule::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	if (m_spCyclicCaller)
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller = NULL;
	m_Trace.Log(tlVerbose, FLEAVEA);
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
// NOTE: 0.0.0.1 backup
//HRESULT CIOSyncModule::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
//{
//	HRESULT hr = S_OK;
//	bool result = false;
//	// handle pending ADS indications and confirmations
//	CheckOrders();
//
//	// TODO: Additional evaluation of input from ADS indication or confirmations
//	//-- If execution is here, IO Sync Task has read all inputs. set input ready flag so each TCOM module can begin executing logic code. ---
//	SetInputReadyFlags();
//	
//
//
//
//
//
//	//-- Wait until all TCOM modules have completed executing logic code. ---
//	result = WaitTillOutputReady(125);		//-- usec
//	if (result)
//	{
//		//-- Reset output ready flag for this cycle ---
//		ResetOutputReadyFlags();
//	}
//	else
//	{
//		//-- Count number of time outs ---
//		CountOutputReadyTimeouts();
//	}
//
//
//
//
//
//
//	// TODO: Submit your ADS requests 
//	ULONGLONG cnt = 0;
//	if (SUCCEEDED(ipTask->GetCycleCounter(&cnt)))
//	{
//		if (cnt % 100 == 0)
//		{
//			SubmitAdsReadReq();
//		}
//	}
//
//	// TODO: Replace the sample with your cyclic code
//	m_Counter += (1 + m_Inputs.Value);
//	m_Outputs.Value = m_Counter;
//
//	return hr;
//}
HRESULT CIOSyncModule::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;
	//bool result = false;
	//// handle pending ADS indications and confirmations
	//CheckOrders();

	//// TODO: Additional evaluation of input from ADS indication or confirmations
	////-- If execution is here, IO Sync Task has read all inputs. set input ready flag so each TCOM module can begin executing logic code. ---
	//SetInputReadyFlags();






	////-- Wait until all TCOM modules have completed executing logic code. ---
	////result = WaitTillOutputReady(75);		//-- usec
	//DelayUsec(m_Debug.DelayUsec);//
	//result = true;
	//if (result)
	//{
	//	//-- Reset output ready flag for this cycle ---
	//	ResetOutputReadyFlags();
	//}
	//else
	//{
	//	//-- Count number of time outs ---
	//	CountOutputReadyTimeouts();
	//}

	////-- NOTE: 0.1.0.1 Added to reset those tasks running slower than IO sync task. If task does not schedule to run this cycle, input ready flag must be reset so that task does not see it ready immediately next time it is scheduled to run.
	////ResetInputReadyFlags();

	//


	//// TODO: Submit your ADS requests 
	//ULONGLONG cnt = 0;
	//if (SUCCEEDED(ipTask->GetCycleCounter(&cnt)))
	//{
	//	if (cnt % 100 == 0)
	//	{
	//		SubmitAdsReadReq();
	//	}
	//}

	//// TODO: Replace the sample with your cyclic code
	////m_Counter += (1 + m_Inputs.Value);
	////m_Outputs.Value = m_Counter;
	//m_Counter++;

	return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///<AutoGeneratedContent id="Obsolete_ImplementationOf_ITcPostCyclic">
//
HRESULT CIOSyncModule::AddModuleToPostCyclicCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	if (m_spPostCyclicCaller.HasOID())
	{
		if (SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spPostCyclicCaller)))
		{
			if (FAILED(hr = m_spPostCyclicCaller->AddPostModule(m_spPostCyclicCaller, THIS_CAST(ITcPostCyclic))))
			{
				m_spPostCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID;
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}


VOID CIOSyncModule::RemoveModuleFromPosyCyclicCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);
	if (m_spPostCyclicCaller)
	{
		m_spPostCyclicCaller->RemovePostModule(m_spPostCyclicCaller);
	}
	m_spPostCyclicCaller = NULL;
	m_Trace.Log(tlVerbose, FLEAVEA);
}

///</AutoGeneratedContent>

///<AutoGeneratedContent id="ImplementationOf_ITcPostCyclic">
HRESULT CIOSyncModule::PostCyclicUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = E_NOTIMPL;

	bool result = false;
	// handle pending ADS indications and confirmations
	CheckOrders();



	LONGLONG cur_pent_time;
	m_spRTime->GetCurPentiumTime(&cur_pent_time);	//ipTask->GetCurPentiumTime(&start_pentium_time);
	m_Debug.CurPentTime = cur_pent_time;

	if (m_spCurPentTimePtr != NULL)
	{
		LONGLONG sync1_pent_time;
		sync1_pent_time = *m_spCurPentTimePtr;

		m_Debug.TimeDiff = cur_pent_time - sync1_pent_time;

		if ((m_Debug.TimeDiff <= 0) || (m_Debug.TimeDiff > m_Debug.TimeDiffLimit))	
		{
			m_Debug.BadCount++; 
		}
		else
		{
			m_Debug.GoodCount++;
		}
	}



	//-- calculate modified position from position bit (before setting InputReadyFlag) ---
	m_Outputs.ModPositionBit = m_Inputs.PositionBit + 100;




	// TODO: Additional evaluation of input from ADS indication or confirmations
	//-- If execution is here, IO Sync Task has read all inputs. set input ready flag so each TCOM module can begin executing logic code. ---
	for (short i = 0; i < NUM_IO_SYNC; i++) SetInputReadyFlag(i);







	if (WaitTillOutputReadyOpt)
	{
		//-- Wait until all TCOM modules have completed executing logic code. ---
		result = WaitTillOutputReady(m_Debug.MaxWaitUsec);		//-- usec
		//DelayUsec(m_Debug.DelayUsec);//
		if (result)
		{
			//-- Reset output ready flag for this cycle ---
			for (short i = 0; i < NUM_IO_SYNC; i++) ResetOutputReadyFlag(i);
		}
		else
		{
			//-- Count number of time outs ---
			for (short i = 0; i < NUM_IO_SYNC; i++) CountOutputReadyTimeout(i);
		}
	}
	//else				//-- cant reset
	//{
	//	DelayUsec(1);	//-- if IO Sync module does not wait untill all TCOM modules are completed, must wait a minimum delay here

	//}






	//#@@# Debug
	m_Debug.SyncFlag0 = IOSyncList[0].syncFlag;
	m_Debug.SyncFlag1 = IOSyncList[1].syncFlag;
	m_Debug.SyncFlag2 = IOSyncList[2].syncFlag;









	//-- NOTE: 0.1.0.1 Added to reset those tasks running slower than IO sync task. If task does not schedule to run this cycle, input ready flag must be reset so that task does not see it ready immediately next time it is scheduled to run.
	//-- NOTE: 0.2.0.1 TCOM module may not synch to IO Sync module on power up. It causes TCOM module to immediately see input ready flag and executing logic

	//-- NOTE: 0.3.0.1 Cant reset it by force here (This reset makes sure things are synced on power up). it wont work when IO sync module does not wait till output ready flags are set
	//for (short i = 0; i < NUM_IO_SYNC; i++) ResetInputReadyFlag(i);











	// TODO: Submit your ADS requests 
	ULONGLONG cnt = 0;
	if (SUCCEEDED(ipTask->GetCycleCounter(&cnt)))
	{
		if (cnt % 100 == 0)
		{
			SubmitAdsReadReq();
		}
	}

	return hr;
}
///</AutoGeneratedContent>

bool CIOSyncModule::WaitTillOutputReady(int time_out_usec)
{
	//m_log.LogStart(1, 1);
	//Wait until inputs wait flag has been set
	LONGLONG currTime, initTime;
	bool time_out_flag = false;

	m_spRTime->GetCurPentiumTime(&initTime);
	//ipTask->GetCurPentiumTime(&initTime);

	// this works too.
	//do
	//{
	//	if (m_spIOSyncIntrf1->GetOutputReadyFlag() && m_spIOSyncIntrf2->GetOutputReadyFlag()) break;

	//	m_spRTime->GetCurPentiumTime(&currTime);
	//	//ipTask->GetCurPentiumTime(&currTime);
	//	if ((currTime - initTime) > (time_out_usec * 10))	//-- 1 time unit is 100ns. so 10 unit is 1 usec.
	//	{
	//		time_out_flag = true;
	//	}
	//} while (!time_out_flag);

	//while ((!m_spIOSyncIntrf1->GetOutputReadyFlag() || !m_spIOSyncIntrf2->GetOutputReadyFlag()) && !time_out_flag)
	while (!IsOutputReady() && !time_out_flag)
	{

		m_spRTime->GetCurPentiumTime(&currTime);
		//ipTask->GetCurPentiumTime(&currTime);
		if ((currTime - initTime) > (time_out_usec * 10))	//-- 1 time unit is 100ns. so 10 unit is 1 usec.
		{
			time_out_flag = true;
		}
	}

	if (time_out_flag)
	{
		m_Trace.Log(tlInfo, "%s timed out waiting for outputs", TcGetObjectName());
	}
	//m_log.LogStop(1, 1);

	return(!time_out_flag);
}

bool CIOSyncModule::IsOutputReady()
{
	for (short i = 0; i < NUM_IO_SYNC; i++)
	{
		if (!GetOutputReadyFlag(i)) return(false);
	}

	return(true);

}

void CIOSyncModule::DelayUsec(int usec)
{
	for (int i = 0; i < usec; i++)
	{
		DelayUsec();
	}
}

void CIOSyncModule::DelayUsec(void)
{
	//if (ipTask == NULL) return;

	LONGLONG cur_pentium_time;
	LONGLONG start_pentium_time;

	m_spRTime->GetCurPentiumTime(&start_pentium_time);	//ipTask->GetCurPentiumTime(&start_pentium_time);
	cur_pentium_time = start_pentium_time;

	//-- pentium time is in 100ns unit. 10 unit is 1000ns or 1us.
	while (cur_pentium_time < start_pentium_time + 10)
	{
		m_spRTime->GetCurPentiumTime(&cur_pentium_time);	//ipTask->GetCurPentiumTime(&cur_pentium_time);
	}

}


///<AutoGeneratedContent id="ImplementationOf_IIOSyncInterface">
SHORT CIOSyncModule::AddModuleToIOSync()
{
	for(short i = 0; i < NUM_IO_SYNC; i++)
	{
		if (IOSyncList[i].syncFlag == false)
		{
			IOSyncList[i].inputReadyFlag = false;		//-- reset first
			IOSyncList[i].outputReadyFlag = false;		//-- reset first
			IOSyncList[i].inputReadyTimeout = 0;		//-- reset first
			IOSyncList[i].outputReadyTimeout = 0;		//-- reset first

			IOSyncList[i].syncFlag = true;				//-- now enabled

			m_Debug.NumSyncModule++;
			return(i);
		}
	}
	return(-1);
}

void CIOSyncModule::RemoveModuleFromIOSync(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		IOSyncList[index].syncFlag = false;
		if(m_Debug.NumSyncModule > 0) m_Debug.NumSyncModule--;
	}
}

bool CIOSyncModule::GetInputReadyFlag(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if(IOSyncList[index].syncFlag) return(IOSyncList[index].inputReadyFlag);
	}
	return(true);	//-- if unused, return true
}

void CIOSyncModule::SetInputReadyFlag(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag) IOSyncList[index].inputReadyFlag = true;
	}
}

void CIOSyncModule::ResetInputReadyFlag(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag) IOSyncList[index].inputReadyFlag = false;
	}
}

bool CIOSyncModule::GetOutputReadyFlag(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag) return(IOSyncList[index].outputReadyFlag);
	}
	return(true);	//-- if unused, return true
}

void CIOSyncModule::SetOutputReadyFlag(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag) IOSyncList[index].outputReadyFlag = true;
	}
}

void CIOSyncModule::ResetOutputReadyFlag(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag) IOSyncList[index].outputReadyFlag = false;
	}
}

LONG CIOSyncModule::GetInputReadyTimeout(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag)
		{
			return(IOSyncList[index].inputReadyTimeout);

		}
	}
	return(0);
}

void CIOSyncModule::CountInputReadyTimeout(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag)
		{
			IOSyncList[index].inputReadyTimeout++;
			
		}
	}
}

void CIOSyncModule::CountOutputReadyTimeout(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag)
		{
			IOSyncList[index].outputReadyTimeout++;
			
		}
	}
}

LONG CIOSyncModule::GetOutputReadyTimeout(SHORT index)
{
	if (index >= 0 && index < NUM_IO_SYNC)
	{
		if (IOSyncList[index].syncFlag)
		{
			return(IOSyncList[index].outputReadyTimeout);

		}
	}
	return(0);
}
///</AutoGeneratedContent>


///////////////////////////////////////////////////////////////////////////////
void CIOSyncModule::AdsReadWriteInd
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG indexGroup,
	ULONG indexOffset,
	ULONG cbReadLength,
	ULONG cbWriteLength,
	PVOID pData
)
{
	m_Trace.Log(tlVerbose, FENTERA "oid=0x%08x, invokeId=%d, indexGroup=0x%08x, indexOffset=0x%08x, cbReadLength=%d, cbWriteLength=%d, pData=0x%p",
		m_objId.value, invokeId, indexGroup, indexOffset, cbReadLength, cbWriteLength, pData);

	switch (indexGroup)
	{
	case IOSyncModuleIndexGroup1:
		switch (indexOffset)
		{

		case IOSyncModuleIndexOffset1:
			m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
				m_objId.value, indexGroup, indexOffset);

			// TODO: add custom code here

			AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL);
			break;

		case IOSyncModuleIndexOffset2:
			m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
				m_objId.value, indexGroup, indexOffset);

			// TODO: add custom code here

			AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL);
			break;
		}
		break;
	case IOSyncModuleIndexGroup2:
		switch (indexOffset)
		{

		case IOSyncModuleIndexOffset1:
			m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
				m_objId.value, indexGroup, indexOffset);

			// TODO: add custom code here

			AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL);
			break;

		case IOSyncModuleIndexOffset2:
			m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x",
				m_objId.value, indexGroup, indexOffset);

			// TODO: add custom code here

			AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL);
			break;
		}
		break;
	default:
		__super::AdsReadWriteInd(rAddr, invokeId, indexGroup, indexOffset, cbReadLength, cbWriteLength, pData);
		break;
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}


void CIOSyncModule::SubmitAdsReadReq()
{
	m_Trace.Log(tlVerbose, FENTERA);
	// m_ContextAdsPort contains the ADS port number of the task associated with context 1
	// amsAddr refers to the ADS port of this task 
	AmsAddr amsAddr(this->AmsGetNetId(), m_ContextAdsPort);

	// Request the value of a parameter from a TwinCAT module instance
	// via the task ADS port.
	// The object id of the instance is passed as index group and
	// the parameter id is passed as index offset.
	// The result is delivered by a call to AdsReadCon and can 
	// be identified by the invoke id. 
	int nRes =
		AdsReadReq
		(
			amsAddr,
			invokeIdReadByOidAndPid,
			m_objId.value,
			PID_IOSyncModuleCounter,
			sizeof(m_ReadByOidAndPid)
		);
	if (nRes != ADSERR_NOERR)
	{
		m_Trace.Log(tlError, FNAMEA "AdsReadReq failed with error=0x%08x(%s)", nRes, AdsGetErrorText(nRes));
	}
	else
	{
		m_Trace.Log(tlInfo, FNAMEA "AdsReadReq by oid=0x%08x and pid=0x%08x", m_objId.value, PID_IOSyncModuleAdsPort);
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}

///////////////////////////////////////////////////////////////////////////////
void CIOSyncModule::AdsReadCon
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG nResult,
	ULONG cbLength,
	PVOID pData
)
{
	m_Trace.Log(tlVerbose, FENTERA "oid=0x%08x, invokeId=%d, nResult=0x%08x, cbLength=%d, pData=0x%p",
		m_objId.value, invokeId, nResult, cbLength, pData);

	if (invokeId == invokeIdReadByOidAndPid)
	{
		if (nResult != ADSERR_NOERR)
		{
			m_Trace.Log(tlWarning, FNAMEA "ReadByOidAndPid failed with error=0x%x(%s)",
				nResult, AdsGetErrorText(nResult));
		}
		else if (cbLength == sizeof(m_ReadByOidAndPid))
		{
			m_ReadByOidAndPid = *static_cast<PULONG>(pData);
			m_Trace.Log(tlInfo, FNAMEA "m_ReadByOidAndPid=0x%x", m_ReadByOidAndPid);
		}
	}
	else
	{
		__super::AdsReadWriteCon(rAddr, invokeId, nResult, cbLength, pData);
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}

